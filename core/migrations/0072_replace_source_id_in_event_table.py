# -*- coding: utf-8 -*-
# Generated by Django 1.9.8 on 2017-03-29 18:34
from __future__ import unicode_literals

from django.db import migrations

from django.db.models.query import Q
from django.db.models.signals import post_save

from core.hooks.allocation_source import (
    listen_for_allocation_threshold_met,
    listen_for_instance_allocation_changes,
    listen_for_allocation_source_created_or_renewed,
    listen_for_allocation_source_compute_allowed_changed
)


def toggle_signals(event_model, on=True):
    if on:
        post_save.connect(listen_for_allocation_threshold_met, sender=event_model)
        post_save.connect(listen_for_instance_allocation_changes, sender=event_model)
        post_save.connect(listen_for_allocation_source_created_or_renewed, sender=event_model)
        post_save.connect(listen_for_allocation_source_compute_allowed_changed, sender=event_model)

    else:
        post_save.disconnect(listen_for_allocation_threshold_met, sender=event_model)
        post_save.disconnect(listen_for_instance_allocation_changes, sender=event_model)
        post_save.disconnect(listen_for_allocation_source_created_or_renewed, sender=event_model)
        post_save.disconnect(listen_for_allocation_source_compute_allowed_changed, sender=event_model)


def replace_sourceid_from_payload(apps, schema_editor):
    EventTable = apps.get_model('core', 'EventTable')
    AllocationSourceModel = apps.get_model('core', 'AllocationSource')
    attr_name = 'name'
    attr_payload = 'payload'
    attr_entity = 'entity_id'

    # Count events & allocations before & after this to make sure we don't accidentally create more records somehow

    event_count_before_delete = EventTable.objects.count()
    print('event_count_before_delete: {}'.format(event_count_before_delete))

    # switch off signals
    toggle_signals(EventTable, on=False)

    # - Delete unused events:
    #   - user_allocation_snapshot_changed
    #   - allocation_source_snapshot
    deleted = EventTable.objects.filter(
        Q(name="user_allocation_snapshot_changed") | Q(name="allocation_source_snapshot")).delete()
    print('deleted: {}'.format(deleted))

    all_source_names = {}

    event_count_before = EventTable.objects.count()
    print('event_count_before: {}'.format(event_count_before))

    for row in EventTable.objects.filter(
                    Q(name="instance_allocation_source_changed") | Q(name="allocation_source_threshold_met")):
        payload = getattr(row, attr_payload)
        if 'allocation_source_id' in payload:
            source_id = payload['allocation_source_id']

            if source_id not in all_source_names:
                source_name = AllocationSourceModel.objects.filter(source_id=source_id).last().name
                all_source_names[source_id] = source_name
            else:
                source_name = all_source_names[source_id]

            if getattr(row, attr_name) == 'instance_allocation_source_changed':
                entity_id = getattr(row, attr_entity)
                new_payload = {"allocation_source_name": source_name, "instance_id": payload["instance_id"]}

                # for old payloads which were incorrect but can't be discarded
                if len(payload.keys()) > 2:
                    new_payload['username'] = payload["username"]

            if getattr(row, attr_name) == 'allocation_source_threshold_met':
                entity_id = source_name
                new_payload = {"allocation_source_name": source_name, "threshold": payload["threshold"],
                               "actual_value": payload["actual_value"]}

            setattr(row, attr_payload, new_payload)
            setattr(row, attr_entity, entity_id)
            row.save()

    # switch signals back on
    toggle_signals(EventTable)
    event_count_after = EventTable.objects.count()
    print('event_count_after: {}'.format(event_count_after))


class Migration(migrations.Migration):
    dependencies = [
        ('core', '0071_provider_more_instance_actions'),
    ]

    operations = [
        migrations.RunPython(
            replace_sourceid_from_payload,
            reverse_code=migrations.RunPython.noop),
    ]
